'use server'

import prisma from '@/lib/prisma'
import { revalidatePath } from 'next/cache'

export async function getDocumentsAction(orgId: string, divisionId?: string) {
    try {
        const where: any = { organization_id: orgId }
        if (divisionId) where.division_id = divisionId

        const documents = await prisma.document.findMany({
            where,
            include: {
                division: { select: { name: true } }
            },
            orderBy: { created_at: 'desc' }
        })

        // Fetch uploader names
        const uploaderIds = [...new Set(documents.map(d => d.uploaded_by))]
        const users = await prisma.user.findMany({ where: { id: { in: uploaderIds } } })
        const userMap = users.reduce((acc, u) => ({ ...acc, [u.id]: u.full_name }), {} as Record<string, string>)

        const data = documents.map(d => ({
            ...d,
            uploader_name: userMap[d.uploaded_by] || 'Unknown'
        }))

        return { success: true, data }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}

export async function getDocumentByIdAction(id: string) {
    try {
        const doc = await prisma.document.findUnique({
            where: { id },
            include: {
                division: { select: { name: true } },
                chunks: { orderBy: { chunk_index: 'asc' } }
            }
        })

        if (!doc) return { success: false, error: 'Document not found' }

        const uploader = await prisma.user.findUnique({ where: { id: doc.uploaded_by } })

        return {
            success: true,
            data: {
                ...doc,
                uploader_name: uploader?.full_name || 'Unknown'
            }
        }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}

export async function createDocumentAction(data: {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    divisionId: string
    orgId: string
    userId: string
}) {
    try {
        const doc = await prisma.document.create({
            data: {
                file_name: data.fileName,
                file_path: data.filePath,
                file_size: data.fileSize,
                mime_type: data.mimeType,
                division_id: data.divisionId,
                organization_id: data.orgId,
                uploaded_by: data.userId,
                is_processed: false
            }
        })

        revalidatePath('/dashboard/documents')
        return { success: true, data: doc }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}

export async function processDocumentAction(docId: string, aiData: {
    title: string
    summary: string
    tags: string[]
    chunks: { content: string; tokenCount: number; pageNumber?: number }[]
}) {
    try {
        await prisma.$transaction(async (tx) => {
            // Update the document metadata
            await tx.document.update({
                where: { id: docId },
                data: {
                    ai_title: aiData.title,
                    ai_summary: aiData.summary,
                    ai_tags: aiData.tags,
                    is_processed: true
                }
            })

            // Create chunks
            for (let i = 0; i < aiData.chunks.length; i++) {
                await tx.documentChunk.create({
                    data: {
                        document_id: docId,
                        chunk_index: i,
                        content: aiData.chunks[i].content,
                        token_count: aiData.chunks[i].tokenCount,
                        page_number: aiData.chunks[i].pageNumber
                    }
                })
            }
        })

        revalidatePath('/dashboard/documents')
        revalidatePath(`/dashboard/documents/${docId}`)
        return { success: true }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}

export async function deleteDocumentAction(id: string) {
    try {
        await prisma.document.delete({ where: { id } })
        revalidatePath('/dashboard/documents')
        return { success: true }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}

export async function searchDocumentsAction(orgId: string, query: string) {
    try {
        // Text-based search across chunks and document metadata
        const results = await prisma.document.findMany({
            where: {
                organization_id: orgId,
                is_processed: true,
                OR: [
                    { ai_title: { contains: query, mode: 'insensitive' } },
                    { ai_summary: { contains: query, mode: 'insensitive' } },
                    { file_name: { contains: query, mode: 'insensitive' } },
                    { chunks: { some: { content: { contains: query, mode: 'insensitive' } } } }
                ]
            },
            include: {
                division: { select: { name: true } },
                chunks: {
                    where: { content: { contains: query, mode: 'insensitive' } },
                    take: 3,
                    orderBy: { chunk_index: 'asc' }
                }
            },
            take: 20
        })

        return { success: true, data: results }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}
